<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-11-14">

<title>Finding clusters of groups with invariant measurement</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Vignette1_files/libs/clipboard/clipboard.min.js"></script>
<script src="Vignette1_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Vignette1_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Vignette1_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="Vignette1_files/libs/quarto-html/popper.min.js"></script>
<script src="Vignette1_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Vignette1_files/libs/quarto-html/anchor.min.js"></script>
<link href="Vignette1_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Vignette1_files/libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Vignette1_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Vignette1_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Vignette1_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#example---clusters-of-groups" id="toc-example---clusters-of-groups" class="nav-link active" data-scroll-target="#example---clusters-of-groups">Example - clusters of groups</a>
  <ul class="collapse">
  <li><a href="#finding-clusters-of-groups-with-mie" id="toc-finding-clusters-of-groups-with-mie" class="nav-link" data-scroll-target="#finding-clusters-of-groups-with-mie">Finding clusters of groups with MIE</a>
  <ul class="collapse">
  <li><a href="#no-measurement-model-implied" id="toc-no-measurement-model-implied" class="nav-link" data-scroll-target="#no-measurement-model-implied">No measurement model implied</a></li>
  <li><a href="#parameters-in-a-global-model" id="toc-parameters-in-a-global-model" class="nav-link" data-scroll-target="#parameters-in-a-global-model">Parameters in a global model</a></li>
  <li><a href="#change-in-fit-indices-of-pairwise-models" id="toc-change-in-fit-indices-of-pairwise-models" class="nav-link" data-scroll-target="#change-in-fit-indices-of-pairwise-models">Change in fit indices of pairwise models</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#comparison-with-other-approaches" id="toc-comparison-with-other-approaches" class="nav-link" data-scroll-target="#comparison-with-other-approaches">Comparison with other approaches</a>
  <ul class="collapse">
  <li><a href="#partial-invariance" id="toc-partial-invariance" class="nav-link" data-scroll-target="#partial-invariance">1. Partial invariance</a></li>
  <li><a href="#alignment-method" id="toc-alignment-method" class="nav-link" data-scroll-target="#alignment-method">2. Alignment method</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Finding clusters of groups with invariant measurement</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 14, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MIE)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(reshape2)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(lavaan)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Comparing psychological constructs, attitudes, or behaviors across groups is one of the most common goals in social and behavioral research. We often want to know whether a latent factor, such as well-being or math anxiety, has the same meaning across populations, cultures, or time points. Before comparing latent means or structural paths, we must ensure that the construct is measured in the same way across groups.</p>
<p>Let’s say you have been developing a measurement scale and at some point you have tested measurement invariance, and the test has failed. You suspect that some groups are non-invariant, but you don’t know which ones. Moreover, if you have many groups, manually testing all pairwise combinations is not feasible. One of a few solutions is to use the multiple groups alignment (or more generally penalized SEM), but it may not be available for your model or software. More flexible solution is to use the Measurement Invariance Explorer (MIE) application, which allows you to explore which groups are similar in terms of measurement model parameters (or even more observed covariances/correlations).</p>
<p>If a factor loading or intercept differs from one group to another, the scale or the origin of the latent variable changes. Observed differences may then reflect differences in how the construct is measured, rather than true differences in the construct itself.</p>
<p>Traditionally, researchers test measurement invariance through a sequence of multiple-group confirmatory factor analysis (MGCFA) models that impose increasing constraints: the configural model (same structure), the metric model (equal loadings), and the scalar model (equal loadings and intercepts). When fit indices remain stable across these steps, invariance is supported.</p>
<p>However, this approach becomes cumbersome when the number of groups increases, as in large cross-national surveys or longitudinal studies with many waves. Even alignment methods (Muthén &amp; Asparouhov, 2013, 2014), which optimize parameters to minimize non-invariance, assume that most parameters are invariant — an assumption that may not always hold.</p>
<p>The Measurement Invariance Explorer (MIE) package provides a new perspective. Instead of strict hypothesis testing, it offers an exploratory and visual framework that helps users detect patterns of similarity and dissimilarity among groups. It complements confirmatory analysis by revealing which groups are similar, which ones differ, and how large those differences are.</p>
<section id="example---clusters-of-groups" class="level1">
<h1>Example - clusters of groups</h1>
<p>To illustrate the idea, we will use simulated data emulating a short scale of political efficacy. It has two factors with four items each:</p>
<pre><code>F1 =~ v1  + v2  + v3  + v4;
F2 =~ v11 + v12 + v13 + v14;</code></pre>
<p>We have 20 countries (with 500 observations in each) and there are 4 regions of countries (East Asia, Western Europe, Eastern Europe, and Latin America), each with different factor loadings. Within each region, countries have similar measurement parameters, but these parameters differ across regions, so true factor loadings are:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>  Parameter Western_Europe Eastern_Europe Latin_America East_Asia
1  F1 by v1              1            1.0           1.0       1.0
2  F1 by v2              1            0.4           0.4       0.4
3  F1 by v3              1            0.3           0.7       0.1
4  F1 by v4              1            0.2           0.7       1.0
5 F2 by v11              1            1.0           1.0       1.0
6 F2 by v12              1            0.4           0.4       0.4
7 F2 by v13              1            0.3           0.7       0.1
8 F2 by v14              1            0.2           0.7       1.0</code></pre>
</div>
</div>
<p>The issue is that we don’t know in advance, that these 4 regions exist, and which countries belong to which region. We only know that we have 20 countries.</p>
<p>Conventional tests of invariance would show that there is no metric invariance, as expected. <code>MIE</code> has a convenient function for this:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>global_mi_test <span class="ot">=</span> <span class="fu">globalMI</span>(</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> <span class="st">'F1 =~ v1  + v2  + v3  + v4;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="st">           F2 =~ v11 + v12 + v13 + v14;'</span>,  </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">group =</span> <span class="st">"group"</span>, </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> sim_data,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">what =</span> <span class="fu">c</span>(<span class="st">"cfi"</span>, <span class="st">"rmsea"</span>, <span class="st">"srmr"</span>),</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">quiet =</span> T</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>global_mi_test<span class="sc">$</span>fit <span class="sc">%&gt;%</span> <span class="fu">round</span>(<span class="dv">3</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>             cfi diff.cfi rmsea diff.rmsea  srmr diff.srmr
configural 1.000       NA 0.000         NA 0.023        NA
metric     0.854   -0.146 0.082      0.082 0.076     0.053
scalar     0.852   -0.002 0.075     -0.008 0.077     0.002</code></pre>
</div>
</div>
<p>Comparing CFI and RMSEA across models shows that metric invariance is not supported. What should we do next? Some of our options are:</p>
<ol type="1">
<li>find a subset of parameters which is invariant across all groups;</li>
</ol>
<ol type="a">
<li>partial invariance (relax some constraints, but not less than two per each factor - Byrne, Shavelson, &amp; Muthen, 1989);</li>
<li>approximate invariance (relax strict equality of parameters, Bayesian zero priors on differences);</li>
</ol>
<ol start="2" type="1">
<li>find a subset of groups:</li>
</ol>
<ol type="a">
<li>alignment method (Muthen &amp; Asparouhov, 2013, 2014a, 2014b), minimizing non-invariance by finding convenient factor means and variances (available only in Mplus), however: <em>“The assumption of the alignment method is that a majority of the parameters are invariant and a minority of the parameters are non-invariant.” (Muthen &amp; Asparouhov, 2013)</em>; the new PSEM approach may help overcome this limitation but a lot is unknown yet.</li>
<li>repeatedly re-run MGCFA model with different subsets of groups - this is the approach that is made easy in MIE.</li>
</ol>
<p>All these methods could be useful, but they all have limitations. Partial invariance may not be feasible if too many parameters are non-invariant, approximate invariance requires Bayesian estimation which may not be available for your model or software, and alignment assumes that most parameters are invariant.</p>
<p>So let’s try stratified invarince methodology.</p>
<section id="finding-clusters-of-groups-with-mie" class="level2">
<h2 class="anchored" data-anchor-id="finding-clusters-of-groups-with-mie">Finding clusters of groups with MIE</h2>
<p>The Measurement Invariance Explorer (MIE) package provides a new perspective. Instead of strict hypothesis testing, it offers an exploratory and visual framework that helps users detect patterns of similarity and dissimilarity among groups. It complements confirmatory analyses by revealing which groups are similar, which ones differ, and how large those differences are. The general idea is to compute some measure of “invariance distance” between each pair of groups, and then use multidimensional scaling (MDS) to visualize these distances in two dimensions and/or clusterize groups. Groups that are close together in the plot are more similar in terms of measurement parameters, while those that are far apart are more dissimilar.</p>
<p>MIE provides many measures of “invariance distance” which can be split into three categories: no measurement model implied (very crude measures based on correlations and covariances), when measurement model implied and we focus on measurement parameters (loadings and intercepts), and based on changes in fit indices of pairwise models. Below is a brief overview of these measures.</p>
<section id="no-measurement-model-implied" class="level3">
<h3 class="anchored" data-anchor-id="no-measurement-model-implied">No measurement model implied</h3>
<ul>
<li><strong>Covariances (no model implied)</strong> Commonly used multidimensional scaling (MDS) of all available indicators. Two dimensions are extracted.</li>
<li><strong>Correlations (no model implied)</strong> After applying Fisher’s z transformation, the distances are computed, sent to MDS and plotted. If the model fits data well, correlations/covariances and model parameters should differ across groups in a similar way.</li>
</ul>
</section>
<section id="parameters-in-a-global-model" class="level3">
<h3 class="anchored" data-anchor-id="parameters-in-a-global-model">Parameters in a global model</h3>
<ul>
<li><p><strong>Parameters: loadings (configural MGCFA)</strong> A single multiple group confirmatory factor analysis with non-constrained factor loadings and intercepts. It extracts loadings, and uses them to compute distance matrix, which is then scaled and plotted.</p></li>
<li><p><strong>Parameters: intercepts (metric MGCFA)</strong> Analogous to previous one, but loadings are constrained and free intercepts are used as a measure of distance between groups.</p></li>
</ul>
</section>
<section id="change-in-fit-indices-of-pairwise-models" class="level3">
<h3 class="anchored" data-anchor-id="change-in-fit-indices-of-pairwise-models">Change in fit indices of pairwise models</h3>
<ul>
<li><strong>Change in fit indices from configural to metric model</strong>
<ol type="1">
<li>Configural and metric MGCFA models are fitted to subsamples of every possible pair of groups.</li>
<li>Global fit indices are extracted and their change between the two models is computed, they reflect “invariance distances” between each pair of groups.</li>
<li>Without further transformations, CFI, RMSEA, or SRMR for each pair of groups are used to compute two-dimensional scaling and plot the group points.</li>
</ol></li>
<li><strong>Change in fit indices from metric to scalar model</strong> Analogous to previous one, only metric and scalar models are fitted to the pairs of groups.</li>
</ul>
<p>All these measures have their pro and cons For example, change in fit indices can be problematic because CFA, RMSEA, and SRMR, as well as their increments do not have known distributions, while calculation of distance assumes normality. Nevertheless, they all may be useful in practice, depending on the data and the research question.</p>
<p>NB. There is also very promising approach called dMACs but it’s not implemented in MIE yet.</p>
<p>Let’s see how MIE works with our simulated data. We need to pick the measure, calculate it, and plot the results. First we will use correlations, next loadings, and finally CFI as measures of distance between groups.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>corrs <span class="ot">&lt;-</span> <span class="fu">getMetrics</span>(</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">group =</span> <span class="st">"group"</span>, </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> sim_data, </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">metric =</span> <span class="st">"correlation"</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plotDistances</span>(corrs)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Optimal number of clusters is  4</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Vignette1_files/figure-html/mie_correlation-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>all_loadings <span class="ot">&lt;-</span> <span class="fu">getMetrics</span>(</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> <span class="st">'F1 =~ v1  + v2  + v3  + v4;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="st">           F2 =~ v11 + v12 + v13 + v14;'</span>,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">group =</span> <span class="st">"group"</span>, </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> sim_data, </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">metric =</span> <span class="st">"parameters"</span>,</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> <span class="st">"loadings"</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="fu">plotDistances</span>(all_loadings)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Optimal number of clusters is  4</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Vignette1_files/figure-html/mie_loadings-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>CFIs <span class="ot">=</span> <span class="fu">getMetrics</span>(</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> <span class="st">'F1 =~ v1  + v2  + v3  + v4;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="st">           F2 =~ v11 + v12 + v13 + v14;'</span>,  </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">group =</span> <span class="st">"group"</span>, </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> sim_data,</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">metric =</span> <span class="st">"fit"</span>,</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">level =</span> <span class="st">"metric"</span>,</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">quiet =</span> T</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="fu">plotDistances</span>(CFIs)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Optimal number of clusters is  5</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Vignette1_files/figure-html/mie_cfi-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Alternatively, we may use a cutoff value rather than a continuous distance to form clusters and show on the plot. For CFI, a cutoff of 0.01 is often used in invariance testing (e.g., following Chen, 2007).</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plotDistances</span>(CFIs, <span class="at">cutoff =</span> <span class="fl">0.01</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Vignette1_files/figure-html/mie_clusters-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Overall, all three measures have managed to recover the true clusters of groups quite well. Correlations and loadings did a perfect job, while CFI made a minor mistake (group Eastern_Europe_G4 was misplaced).</p>
<p>Now, that we found clusters of similar groups, we can run a stratified MGCFA models on these clusters to test for invariance within each cluster. There is a convenience function for this too:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># first, let's get the strata based on CFI distances</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>distance_plot <span class="ot">&lt;-</span> <span class="fu">plotDistances</span>(CFIs, <span class="at">cutoff =</span> <span class="fl">0.01</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co"># You can automate getting clusters, for example, like this, </span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co"># but it's recommended to visually inspect the plot and define clusters manually.</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># lapply(setNames(nm=unique(distance_plot$data$cluster)), function(x) {</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">#    distance_plot$data$group[distance_plot$data$cluster == x]</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co"># })</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="fu">stratifiedMI</span>(</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> <span class="st">'F1 =~ v1  + v2  + v3  + v4;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="st">           F2 =~ v11 + v12 + v13 + v14;'</span>,  </span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  <span class="at">group =</span> <span class="st">"group"</span>, </span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> sim_data, </span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>  <span class="at">strata =</span> <span class="fu">list</span>(<span class="st">"East_Asia"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"East_Asia_G1"</span>, <span class="st">"East_Asia_G2"</span>, <span class="st">"East_Asia_G3"</span>, <span class="st">"East_Asia_G4"</span>, <span class="st">"East_Asia_G5"</span>), </span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>                <span class="st">"Eastern_Europe"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"Eastern_Europe_G1"</span>, <span class="st">"Eastern_Europe_G2"</span>, <span class="st">"Eastern_Europe_G3"</span>, <span class="st">"Eastern_Europe_G4"</span>, <span class="st">"Eastern_Europe_G5"</span>), </span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>                <span class="st">"Latin_America"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"Latin_America_G1"</span>, <span class="st">"Latin_America_G2"</span>, <span class="st">"Latin_America_G3"</span>, <span class="st">"Latin_America_G4"</span>, <span class="st">"Latin_America_G5"</span>), </span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>                <span class="st">"Western_Europe"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"Western_Europe_G1"</span>, <span class="st">"Western_Europe_G2"</span>, <span class="st">"Western_Europe_G3"</span>, <span class="st">"Western_Europe_G4"</span>, <span class="st">"Western_Europe_G5"</span>))</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>  )</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
                    cfi tli rmsea  srmr    bic  df cfi    tli rmsea  srmr   bic
fits[[ref]]           1   1 0.000 0.023 254337 380                             
fits[["clustered"]]   1   1 0.003 0.035 252526 604   0 -0.003 0.003 0.012 -1811
                     df
fits[[ref]]            
fits[["clustered"]] 224</code></pre>
</div>
</div>
<p>The results show that within each cluster, metric invariance holds very well (CFI remains high and stable, RMSEA and SRMR are low while df is drastically different). This confirms that the clusters identified by MIE are meaningful in terms of measurement invariance.</p>
</section>
</section>
</section>
<section id="comparison-with-other-approaches" class="level1">
<h1>Comparison with other approaches</h1>
<p>Let’s go quickly through some other options available with the same dataset.</p>
<section id="partial-invariance" class="level2">
<h2 class="anchored" data-anchor-id="partial-invariance">1. Partial invariance</h2>
<p>Before we can fit the partial metric model we need to identify what parameters are non-invariant.</p>
<p>Let’s use the metric model already fitted in the previous step and run a score test. It is available in <code>lavaan</code> through <code>lavTestScore</code> function, but its output is not very user-friendly. <code>MIE</code> provides a wrapper version of the output through <code>lavTestScore_clean</code> function. (Note, both take a substantial time to compute, ~1-2min in this case).</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>score_test <span class="ot">=</span> <span class="fu">lavTestScore_clean</span>(global_mi_test<span class="sc">$</span>models<span class="sc">$</span>metric)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(score_test<span class="sc">$</span>uni)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Chi-square test of releasing single constraints, equivalent to modification indices

     Term       Group1       Group2 Chi.square df p.value   .
1  F1=~v2 East_Asia_G1 East_Asia_G5      0.981  1   0.322    
2  F1=~v3 East_Asia_G1 East_Asia_G5     91.762  1   0.000 ***
3  F1=~v4 East_Asia_G1 East_Asia_G5     20.226  1   0.000 ***
4 F2=~v12 East_Asia_G1 East_Asia_G5      4.100  1   0.043 *  
5 F2=~v13 East_Asia_G1 East_Asia_G5     42.148  1   0.000 ***
6 F2=~v14 East_Asia_G1 East_Asia_G5     15.037  1   0.000 ***</code></pre>
</div>
</div>
<p>The table is very long and it is tedious to look through all of it. To get a quick overview of which parameters are most non-invariant across groups, we can aggregate the score test statistics by group:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>score_test<span class="sc">$</span>uni <span class="sc">%&gt;%</span> </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(Term) <span class="sc">%&gt;%</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">Chi.square.sum =</span> <span class="fu">sum</span>(Chi.square)) <span class="sc">%&gt;%</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(Chi.square.sum))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 2
  Term    Chi.square.sum
  &lt;chr&gt;            &lt;dbl&gt;
1 F1=~v3            470.
2 F2=~v13           318.
3 F1=~v4            251.
4 F2=~v14           217.
5 F1=~v2            174.
6 F2=~v12           145.</code></pre>
</div>
</div>
<p>Now we have to rerun the model with partial invariance, freeing the most non-invariant parameters. Let’s free loadings of v3, v13, v4, and v12 – these were the groups with the highest score test statistics for these parameters and it’s the maximum number of free loadings we could afford in a partial invariance model (recall that partial metric invariance requires at least two invariant loadings).</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>global_mi_test2 <span class="ot">=</span> <span class="fu">globalMI</span>(</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> <span class="st">'F1 =~ v1  + v2  + v3  + v4;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="st">           F2 =~ v11 + v12 + v13 + v14;'</span>,  </span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">group =</span> <span class="st">"group"</span>, </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> sim_data,</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">partial =</span> <span class="fu">c</span>(<span class="st">"F1=~v3"</span>, <span class="st">"F2=~v13"</span>, <span class="st">"F1=~v4"</span>, <span class="st">"F2=~v12"</span>),</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">omit =</span> <span class="st">'scalar'</span>,</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">what =</span> <span class="fu">c</span>(<span class="st">"cfi"</span>, <span class="st">"rmsea"</span>, <span class="st">"srmr"</span>),</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">quiet =</span> T</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>global_mi_test2<span class="sc">$</span>fit <span class="sc">%&gt;%</span> <span class="fu">round</span>(<span class="dv">3</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>                 cfi diff.cfi rmsea diff.rmsea  srmr diff.srmr
configural     1.000       NA 0.000         NA 0.023        NA
metric         0.854   -0.146 0.082      0.082 0.076     0.053
partial.metric 0.961    0.107 0.046     -0.036 0.046    -0.030</code></pre>
</div>
</div>
<p>The fit has improved, but still not enough to claim metric invariance. Moreover, we had to make a lot of decisions along the way (which parameters to free, how many of them, etc), which makes the process subjective and not very reproducible. Overall, this approach doesn’t work here because (we know it) all the loadings are non-invariant, wo relaxing constraints on some of them won’t help.</p>
<p>So maybe alignment could help?</p>
</section>
<section id="alignment-method" class="level2">
<h2 class="anchored" data-anchor-id="alignment-method">2. Alignment method</h2>
<p>The alignment method is available in Mplus, and it’s getting more and more flexible. The idea is to find factor loadings and intercepts that minimize non-invariance across groups. However, as mentioned before, it assumes that most parameters are invariant, which is not the case here. Still, let’s see what happens. Running alignment may involve multiple steps (see an <a href="https://maksimrudnev.com/2019/05/01/alignment-tutorial/">in-depth alignment tutorial</a>), but <code>MIE</code> automates its typical steps.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>align_res <span class="ot">=</span> <span class="fu">runAlignment</span>(</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">model =</span> <span class="st">'F1 BY v1 v2 v3 v4;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="st">           F2 BY v11 v12 v13 v14;'</span>,  </span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">group =</span> <span class="st">"group"</span>, </span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">dat =</span> sim_data,</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">Mplus_com =</span> <span class="st">"/Applications/Mplus/mplus"</span>,</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">sim.samples =</span> <span class="cn">NULL</span>,</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">path =</span> <span class="fu">tempdir</span>(),</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">summaries =</span> T</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>align_res<span class="sc">$</span>fixed<span class="sc">$</span>summary <span class="sc">%&gt;%</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="fu">grepl</span>(<span class="st">"Loadings"</span>, <span class="fu">row.names</span>(.))) <span class="sc">%&gt;%</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="dv">3</span><span class="sc">:</span><span class="dv">6</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>                    N_invariant N_noninvariant
Loadings  F1 by V1           18              2
Loadings  F1 by V2           19              1
Loadings  F1 by V3           14              6
Loadings  F1 by V4           15              5
Loadings  F2 by V11          20              0
Loadings  F2 by V12          20              0
Loadings  F2 by V13          11              9
Loadings  F2 by V14          15              5
                                                          invariant.gr
Loadings  F1 by V1        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 17 18 19
Loadings  F1 by V2     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 17 18 19 20
Loadings  F1 by V3              6 7 8 10 11 12 13 14 15 16 17 18 19 20
Loadings  F1 by V4             1 2 3 4 5 11 12 13 14 15 16 17 18 19 20
Loadings  F2 by V11 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Loadings  F2 by V12 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Loadings  F2 by V13                   10 11 12 13 14 15 16 17 18 19 20
Loadings  F2 by V14            1 2 3 4 5 11 12 13 14 15 16 17 18 19 20
                         non.invar.gr
Loadings  F1 by V1              16 20
Loadings  F1 by V2                 16
Loadings  F1 by V3        2 3 4 5 9 1
Loadings  F1 by V4         6 7 8 9 10
Loadings  F2 by V11                  
Loadings  F2 by V12                  
Loadings  F2 by V13 2 3 4 5 6 7 8 9 1
Loadings  F2 by V14        6 7 8 9 10</code></pre>
</div>
</div>
<p>As we can see, the alignment has not managed to identify groups with non-invariant loadings very well. It approached a part of the true pattern, for example, for loading on V4 and V14 it indicated groups 6-10 which is indeed the largest outlier in terms of its loadings, but the remaining patterns are blurred. This is expected, given that the assumption of most parameters being invariant is violated.</p>
<p>To sum up, MIE provides a flexible and visual framework to explore measurement invariance across many groups. It can help identify clusters of similar groups when traditional methods struggle. However, it is exploratory in nature and should be complemented with confirmatory analyses.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>